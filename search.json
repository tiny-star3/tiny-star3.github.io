[{"title":"My New Post","url":"/2025/07/22/Life/My-New-Post/","content":"新的开始！\n渺如尘埃，灿若星辰！！！\n终于成功创建了这个个人博客，大学开始，搞到一半放弃了，现在大学毕业去读研，研0暑假终于弄好了。\n","categories":["Life"],"tags":["life"]},{"title":"伯乐码-农大夏令营","url":"/2025/07/31/Life/blm-Agricultural-University-Summer-Camp/","content":"2025.7.6-2025.7.21伯乐码-农大集训营搬砖\n\n7点不到起，9点半回酒店，真牛马！一共150*15&#x3D;2250元，有钱还是不亏，反正没事做。小朋友还是挺可爱的，还是能回忆一下，下面是一些小朋友照片。（PS：视频就不传了，太耗空间了，到时候有时间剪出来传抖音和B站，名字都是渺如星辰。）\naction4拍的，韩诗博，（action4拍照还是不行，什么时候得买台相机了）\n来张集体运动照（action4拍的）\n接下来是手机拍的，画质好不少，action4拍照还是太鸡肋了\n成功逮捕某人玩游戏😒（谭宇轩）\n酒店还在玩😝\n猜猜在干嘛，学霸与学渣🤨\n欠我两瓶水的人-吃饭聊天专属🧐（彭本航）\n某个害羞boy🤭（许嘉鸿）（视频拍得多点😈）\n","categories":["Life"],"tags":["work"]},{"title":"Hello World","url":"/2025/07/22/Sundry/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["Sundry"]},{"title":"STL容器底层实现","url":"/2025/08/01/Cpp/STL%E5%AE%B9%E5%99%A8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/","content":"","categories":["Cpp"],"tags":["STL"]},{"title":"C++2.0新特性","url":"/2025/08/01/Cpp/C++2.0%E6%96%B0%E7%89%B9%E6%80%A7/","content":"C++2.0新特性包括语言和标准库两个层面。\n\n标准库层面以header files（头文件）形式体现C++标准库的header files不带副档名（.h），例如#include&lt;vector&gt;新式C header files不带副名称.h，例如#include&lt;cstdio&gt;旧式C header files（带有副名称.h）仍可用，例如#include&lt;stdio.h&gt;标准库都放在命名空间std里面 ，使用标准库要么使用using namespace std或者std::\nDevC++ 上的 ISO C++11 开关Project -&gt; Project Options -&gt; Compiler -&gt; Code Generation -&gt; Language standard（-std）-&gt;选择 ISO C++11\n资源网站C++11 FAQ，from Stroustrup\nCPlusPlus.com\nCppReference.com\nGCC, the GNU Compiler Collection - GNU Project\n确认支持C++11：macro __cplusplusstd::cout&lt;&lt;__cplusplus;\n\n输出199711则不支持C++11，输出201103及以上则支持C++11\nVariadic Templates（数量不定的模板参数）void print() // 无参数时调用，必须有&#123;&#125;template&lt;typename T, typename... Types&gt;void print(const T&amp; firstArg, const Type&amp;... args)&#123;\tcout&lt;&lt;firstArg&lt;&lt;endl;\t//print first argument\tprint(args...);\t\t\t//call print() for remaining arguments&#125;\n\n**…**就是一个所谓的pack（包）\n用于 template parameters，就是 template parameters pack（模板参数包）用于 function parameter types，就是 function parameter types pack（函数参数类型包）用于 function parameters，就是 function parameters pack（函数参数包）\nprint(7.5, &quot;hello&quot;, bitset&lt;16&gt;(377), 42);// 输出结果为：// 7.5// hello// 0000000101111001// 42\n\n// 与上面那个可以并存template&lt;typename... Types&gt;void print(const Types&amp;... args)&#123;&#125;\n\nnullptr and std::nullptr_t（空指针）C++11 lets you use nullptr instead of 0 or NULLnullptr has type std::nullptr_t, defined in &lt;cstddef&gt;\nAutomatic Type Deduction with auto（自动类型推导）With C++11, you can declare a variable or an object without specifying its specific type by using autoUsing auto is especially usefull where the type is a pretty long and&#x2F;or complicated expression.\nvector&lt;string&gt; v;auto pos = v.begin();\t\t// pos has type vector&lt;string&gt;::iteratorauto l = [](int x)-&gt;bool&#123;\t// l has the type of a lambda    \t\t\t\t\t  // taking an int and returning a bool&#125;;\n\nUniform Initialization（统一初始化&#x2F;一致性初始化）变量名后面加大括号{}\nint values[]&#123;1,2,3&#125;;vector&lt;int&gt; v&#123;2,3,5,7,11,13,17&#125;;vector&lt;string&gt; cities&#123;&quot;Berlin&quot;,&quot;New York&quot;,&quot;London&quot;,&quot;Braunschweig&quot;,&quot;Cairo&quot;,&quot;Cologne&quot;&#125;;// 这形成一个 initializer_list&lt;string&gt;，背后有个 array&lt;string,6&gt; 。调用 vector&lt;string&gt;ctors 时编译器找到了一个  vector&lt;string&gt;ctor 接受 initializer_list&lt;string&gt; 。所有容器皆有如此 ctor complex&lt;double&gt; c&#123;4.0,3.0&#125;; // equivalent to c(4.0,3.0)// 这形成一个 initializer_list&lt;double&gt;，背后有个 array&lt;double,2&gt; 。调用 complex&lt;double&gt;ctor 时该 array 内的2个元素被分解传给 ctor。complex&lt;double&gt; 并无任何 ctor 接受 initializer_list&lt;double&gt;\n\n编译器看到 {t1,t2…tn} 便做出一个initializer_list&lt;T&gt;(T为 t1,t2…tn 类型)，它关联至一个array&lt;T,n&gt;。调用函数（例如ctor）时该array内的元素可被编译器分解逐一赋给函数。但若函数参数是个initializer_list&lt;T&gt;，调用者却不能给予数个T参数然后以为它们会被自动转为一个**initializer_list&lt;T&gt;**传入。\n","categories":["Cpp"],"tags":["C++2.0"]},{"title":"STL常用算法","url":"/2025/08/01/Algorithm/STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","content":"一些好用的算法函数，能记就记吧，记不住还得自己写😭😭😭\n\n\n头文件&lt;algorithm&gt;1.全排列函数next_permutationbool next_permutation(start,end)是C++中常用的全排列函数。它的作用是求当前排列的下一个排列（按字典序升序的下一个排列）。当前排列的下一个排列不存在时，返回false，否则返回true\n// 输出数组a的全排列#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std;int main()&#123;\tint a[4]=&#123;1,2,3,4&#125;;\tcout&lt;&lt;a[0]&lt;&lt;a[1]&lt;&lt;a[2]&lt;&lt;a[3]&lt;&lt;endl;\twhile(next_permutation(a,a+4))\t&#123;\t\tcout&lt;&lt;a[0]&lt;&lt;a[1]&lt;&lt;a[2]&lt;&lt;a[3]&lt;&lt;endl;\t&#125;\treturn 0;&#125;\n\n2.序列排序函数sort3.二分查找函数lower_bound()：返回大于或等于目标值的第一个位置upper_bound()：返回大于目标值的第一个位置binary_search()：若目标值存在则返回true，否则返回false\n4.序列容器遍历函数find()：find_if()：equal()：count()：for_each()：\n5.序列修改函数swap()：replace()：replace_if()：\n头文件&lt;cstring&gt;头文件&lt;cmath&gt;头文件&lt;numeric&gt;accumulate\n头文件&lt;cstdlib&gt;atoi():\n","categories":["Algorithm"],"tags":["STL"]},{"title":"STL常用容器","url":"/2025/07/31/Algorithm/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/","content":"无情的搬运工！（从CSDN往回搬）\nSTL容器底层实现，移步Cpp    链接先欠着，还没开始写&#x2F;(ㄒoㄒ)&#x2F;~~\n\n\nvector1.aboutvector可理解为变长数组，内部实现基于倍增思想。vector支持随机访问，即对于任意的下标0&lt;&#x3D;i&lt;n，可以像数组一样用 [i] 取值。\n2.声明#include&lt;vector&gt;\t\t\t//头文件vector&lt;int&gt; a;\t\t\t\t//相当于一个长度动态变化的int数组vector&lt;int&gt; b[233];\t\t\t//相当于第一维长233，第二维长度动态变化的int数组vector&lt;vector&lt;int&gt;&gt; c;\t\t//相当于一个第一维和第二维的长度动态变化的二维int数组struct rec&#123;...&#125;;vector&lt;rec&gt; d;\t\t\t\t//自定义的结构体类型也可以保存在vector中vector&lt;T&gt; v1;\t\t\t\t//v1 是一个元素类型为 T 的空 vectorvector&lt;T&gt; v2(v1);\t\t\t//使 v1 中所有元素初始化 v2vector&lt;T&gt; v2 = v1;\t\t\t//使 v1 中所有元素初始化 v2vector&lt;T&gt; v3(n, val);\t\t//v3 中包含了 n 个值为 val 的元素vector&lt;T&gt; v4(n);\t\t\t//v4 中包含了 n 个默认值初始化的元素vector&lt;T&gt; v5&#123;a, b, c...&#125;;\t//使用 a, b, c... 初始化 v5vector&lt;T&gt; v6(*p, *q);\t\t//使用另外一个数组的指针来初始化v6，这里即可以使用vector的指针，也可以使用普通数组的指针。 \n\n3.size&#x2F;emptysize函数返回vector的实际长度（包含的元素个数）。empty函数返回一个bool类型，表明vector是否为空。\n注：所有的STL容易都支持这两个方法，含义也都相同。\na.size();\t\t\t//返回数组vector a的长度a.empty();\t\t\t//返回一个bool值，true为vector为空，false为vector不为空\n\n时间复杂度：常数，即 O(1)\n4.clearclear函数把vector清空。\na.clear();\t\t\t//清空数组vector a\n\n时间复杂度：线性，即 O(n)\n5.迭代器迭代器就像STL容器的”指针“，可以用星号”*“操作符解除引用。vector的迭代器是”随机访问迭代器“，可以把vector的迭代器与一个整数相加减，其行为和指针的移动类似。可以把vector的两个迭代器相减，其结果也和指针相减类似，得到两个迭代器对应下标之间的距离。\n一个保存int的vector的迭代器声明方法为：\nvector&lt;int&gt;::iterator it;\t\t\t\n\n6.begin&#x2F;endbegin函数返回指向vector中第一个元素的迭代器。例如a是一个非空的vector，则 *a.begin() 与 a[0] 的作用相同。所有容器都可以视作一个”前闭后开“的结构，end函数返回vector的尾部，即第n个元素再往后的”边界“。 *a.end() 与 a[n] 都是越界访问，其中 n&#x3D;a.size()。\n下标遍历vector数组\nfor(int i=0;i&lt;a.size();i++)&#123;    cout&lt;&lt;a[i]&lt;&lt;endl;&#125;\n\n迭代器遍历vector数组\nfor(vector&lt;int&gt;::iterator it=a.begin();it!=a.end();it++)&#123;    cout&lt;&lt;*it&lt;&lt;endl;\t\t\t//遍历输出数组vector a的值&#125;\n\n时间复杂度：常数，即 O(1)\n7.front&#x2F;backfront函数返回vector的第一个元素，等价于 *a.begin() 和 a[0]。back函数返回vector的最后一个元素，等价于 *–a.end() 和 a[a.size()-1]。\na.front()\t\t\t//返回数组vector a的第一个元素a.back()\t\t\t//返回数组vector a的最后一个元素\n\n时间复杂度：常数，即 O(1)\n8.push_back&#x2F;pop_backpush_back(x)函数将元素x插入到vector的尾部。pop_back()函数删除vector的最后一个元素。\na.push_back(x)\t\t\t//把元素x插入到vector a的尾部a.pop_back()\t\t\t//删除vector a的最后一个元素\n\n时间复杂度：常数，即 O(1)\n9.resizeresize() 改变vector的大小。如果 n 小于当前大小，则销毁额外的元素。如果 n 大于当前容器大小，则在向量末尾插入新元素。\nvoid resize (size_type n);void resize (size_type n, const value_type&amp; val);\t\t\t//n为新容器的大小，val为容器元素的初始值\n\n时间复杂度：线性，即 O(n)\n10.emplace_back（C++ 11）emplace_back()在向量的末尾插入新元素。如果需要更多空间，则会发生重新分配。此方法将容器大小增加一倍。\nvoid emplace_back (Args&amp;&amp;... args);\t\t\t//转发参数以构造新元素。a.emplace_back(b);\t\t\t//在a的末尾插入b\n\n时间复杂度：常数，即 O(1)\n11.insertinsert()在容器中的 position 插入新元素来扩展向量。如果需要更多空间，则会发生重新分配。此函数将容器大小增加一。\niterator insert (const_iterator position, const value_type&amp; val);\t//position为向量中要插入新元素的索引。val为要分配给新插入元素的值。返回一个指向新插入元素的迭代器。\n\n时间复杂度：线性，即 O(n)\n12.eraseerase() 从vector中删除单个元素，从vector中删除元素范围。\niterator erase (const_iterator position);\t//position为迭代器指向向量元素。返回一个被删除元素后面的元素的迭代器。iterator erase (const_iterator first, const_iterator last);//first为输入迭代器到范围内的初始位置。last为输入迭代器到范围内的最终位置。返回一个被删除元素后面的元素迭代器。\n\n时间复杂度：线性，即 O(n)\nqueue1.about头文件queue主要包括循环队列queue和优先队列priority_queue两个容器。\n2.声明#include &lt;queue&gt;\t\t\t\t\t\t//头文件queue&lt;int&gt; q1;\t\t\t\t\t\t\t//存储int的队列struct rec&#123;...&#125;;queue&lt;rec&gt; q2;priority_queue&lt;int&gt; q3;priority_queue&lt;pair&lt;int,int&gt;&gt; q4;priority_queue&lt;int,vector,less&gt; q5;\t\t\t//最大堆（默认为最大堆）priority_queue&lt;int,vector,greater&gt; q6;\t\t//最小堆\n\n注：pair&lt;&gt;: C++内置的二元组，尖括号分别指定二元组的第一元、第二元的类型。可以用make_pair函数创建二元组，用成员变量first访问第一元、second访问第二元。在比较大小时，以第一元为第一关键字、第二元为第二关键字。\n3.循环队列queue\n\n\n方法\n描述\n实例\n时间复杂度\n\n\n\npush\n入队（从队尾)\nq.push(element);\nO(1)\n\n\npop\n出队（从队头）\nq.pop();\nO(1)\n\n\nfront\n队头元素\nint x &#x3D; q.front();\nO(1)\n\n\nback\n队尾元素\nint y &#x3D; q.back();\nO(1)\n\n\nsize\n实际长度（包含的元素个数）\nint z &#x3D; q.size();\nO(1)\n\n\nempty\n是否为空\nbool a&#x3D;q.empty();\nO(1)\n\n\n4.优先队列priority_queue\n\n\n方法\n描述\n实例\n时间复杂度\n\n\n\nsize\n实际长度（包含的元素个数）\nint x &#x3D; q.size();\nO(1)\n\n\nempty\n是否为空\nbool y &#x3D; q.empty();\nO(1)\n\n\npush\n把元素插入堆\nq.push(x);\nO(logn)\n\n\npop\n删除堆顶元素\nq.pop();\nO(logn)\n\n\ntop\n查询栈顶元素（最大值）\nint z &#x3D; q.top();\nO(1)\n\n\ndeque1.about双端队列deque是一个支持在两端高效插入或删除元素的连续线性存储空间。它就像是vector和queue的结合。与vector相比，deque在头部增删元素仅需要 O(1)；与queue相比，deque像数组一样支持随机访问。\n2.声明#include &lt;deque&gt;\t\t\t\t\t\t\t\t//头文件deque&lt;int&gt; d1;    \t\t\t\t\t\t\t\t//创建一个empty的int型队列deque&lt;int&gt; d2(8);  \t\t\t\t\t\t\t\t//创建一个有8个元素的int型队列，默认初始化值(value)为0deque&lt;int&gt; d3(8, 50);  \t\t\t\t\t\t\t//创建一个有8个元素的int型队列，默认初始化值(value)都设为50deque&lt;int&gt; d4(d1.begin(), d1.end()); \t\t\t//通过迭代器创建队列deque&lt;int&gt; d5(d1);    \t\t\t\t\t\t\t//通过拷贝构造创建队列\n\n\n\n3.method\n\n\n方法\n描述\n示例\n时间复杂度\n\n\n\nsize\n实际长度（包含的元素个数）\nint x &#x3D; d.size();\nO(1)\n\n\nempty\nd是否为空\nbool y &#x3D; d.empty();\nO(1)\n\n\n[]\n随机访问\nint z &#x3D; d[0];\nO(1)\n\n\nbegin\ndeque的头迭代器\ndeque::iterator it1 &#x3D; d.begin();\nO(1)\n\n\nend\ndeque的尾迭代器\ndeque::iterator it2 &#x3D; d.end();\nO(1)\n\n\nfront\n队头元素\nint a &#x3D; d.front();\nO(1)\n\n\nback\n队尾元素\nint b &#x3D; d.back();\nO(1)\n\n\npush_back\n从队尾入队\nd.push_back(x);\nO(1)\n\n\npush_front\n从队头入队\nd.push_front(y);\nO(1)\n\n\npop_front\n从队头出队\nd.pop_front();\nO(1)\n\n\npop_back\n从队尾出队\nd.pop_back();\nO(1)\n\n\nclear\n清空队列\nd.clear();\nO(n)\n\n\nstack1.aboutstack&lt;T&gt;容器适配器中的数据是以 LIFO 的方式组织的，即先进后出，当想访问栈内某一元素时，必须将其顶部的元素都弹出出栈后，才能访问该元素。\n2.声明#include &lt;stack&gt;\t\t\t\t\t\t//头文件stack&lt;int&gt; s1;\t\t\t\t\t\t\t//存储int的栈struct rec&#123;...&#125;;stack&lt;rec&gt; s2;\n\n3.method\n\n\n方法\n描述\n实例\n时间复杂度\n\n\n\nsize\n实际长度（包含的元素个数）\nint x &#x3D; s.size();\nO(1)\n\n\nempty\n是否为空\nbool y &#x3D; s.empty();\nO(1)\n\n\ntop\n栈顶元素\nint z &#x3D; s.top();\nO(1)\n\n\npush\n入栈（从栈顶）\ns.push(a);\nO(1)\n\n\npop\n出栈（从栈顶）\ns.pop();\nO(1)\n\n\nset1.about头文件set主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集”，即前者的元素不能重复，而后者可以包含若干个相等的元素。set和multiset的内部实现是一颗红黑树（平衡树的一种），它们支持的函数基本相同。\n2.声明#include &lt;set&gt;\t\t\t\t\t\t\t//头文件set&lt;int&gt; s1;\t\t\t\t\t\t\t//存储int的有序集合setstruct rec&#123;...&#125;;set&lt;rec&gt; s2;multiset&lt;double&gt; s3;set&lt;Type&gt; s\t\t\t\t\t\t      \t//定义一个set容器set&lt;Type&gt; s(s1)\t\t\t              \t//定义一个set容器，并用容器s1来初始化set&lt;Type&gt; s(b, e)\t\t\t\t\t  \t//b和e分别为迭代器的开始和结束的标记set&lt;Type&gt; s(s1.begin(), s1.begin()+3) \t//用容器s1的第0个到第2个值初始化sset&lt;Type&gt; s(a, a + 5)      \t\t      \t//将a数组的元素初始化vec向量，不包括a[4]set&lt;Type&gt; s(&amp;a[1], &amp;a[4]) \t\t\t  \t//将a[1]~a[4]范围内的元素作为s的初始值\n\nset和multiset存储的元素必须定义“小于号”运算符。\n3.迭代器set和multiset的迭代器称为“双向访问迭代器”。不支持“随机访问”，支持星号 (*) 解除引用，仅支持“++”和“–”两个与算术相关的操作。\nset&lt;int&gt;::iterator it;it = s.begin();it++;//it将指向“下一个”元素。这里的“下一个”是指在元素从小到大排序的结果中，排在it下一名的元素。it--;//同理，it将会指向排在“上一个”的元素。//执行“++”和“--”操作的时间复杂度都是O(logn)。//执行操作前后，务必仔细检查，避免迭代器指向的位置超出首、尾迭代器之间的范围。\n\n4.method\n\n\n方法\n描述\n实例\n时间复杂度\n\n\n\nsize\n实际长度（包含的元素个数）\nint x &#x3D; s.size();\nO(1)\n\n\nempty\n是否为空\nbool y &#x3D; s.empty();\nO(1)\n\n\nclear\n清空\ns.clear();\nO(n)\n\n\nbegin\n返回集合的首迭代器\nset::iterator it1 &#x3D; s.begin();\nO(1)\n\n\nend\n返回集合的尾迭代器\nset::iterator it2 &#x3D; s.end();\nO(1)\n\n\ninsert\n将一个元素插入到集合\ns.insert(x);\nO(logn)\n\n\nfind\n在集合中查找等于x的元素，并返回指向该元素的迭代器。如不存在，返回s.end()\nset::iterator it &#x3D; s.find(x);\nO(logn)\n\n\nlower_bound\n查找&gt;&#x3D;x的元素中最小的一个，并返回指向该元素的迭代器\nset::iterator it &#x3D; s.lower_bound(x);\nO(logn)\n\n\nupper_bound\n查找&gt;x的元素中最小的一个，并返回指向该元素的迭代器\nset::iterator it &#x3D; s.upper_bound(x);\nO(logn)\n\n\nerase\n从集合中删除迭代器 it 指向的元素                                                              从集合中删除所有等于x的元素\ns.erase(it);                           s.erase(x);\nO(logn)           O(k+logn)，k为被删除元素个数\n\n\ncount\n返回集合中等于x的元素个数\nint y &#x3D; s.count(x);\nO(k+logn)，k为元素x个数\n\n\nbitset1.aboutbitset可看作一个多位二进制数，每8位占用1个字节，相当于采用了状态压缩的二进制数组，并支持基本的位运算。在估算程序运行的时间时，一般以32位整数的运算次数为基准，因此n位 bitset 执行一次位运算的复杂度可视为n&#x2F;32，效率较高。\n2.声明和初始化#include &lt;bitset&gt;\t\t\t\t//头文件bitset&lt;10000&gt; b;\t\t\t\t//表示一个10000位二进制数，&lt;&gt;中填写位数。bitset&lt;n&gt; b;\t          \t\t//b有n位，每位都为0bitset&lt;n&gt; b(u);\t          \t\t//b是unsigned long型u的一个副本bitset&lt;n&gt; b(s);\t          \t\t//b是string对象s中含有的位串的副本bitset&lt;n&gt; b(s, pos, n);\t  \t\t//b是s中从位置pos开始的n个位的副本\n\n3.位运算操作符~b：返回对bitset b按位取反的结果。&amp;, |, ^：返回对两个位数相同的bitset执行按位与、或、异或运算的结果。&gt;&gt;, &lt;&lt;：返回把一个bitset右移、左移若干位的结果。&#x3D;&#x3D;, !&#x3D;：比较两个bitset代表的二进制数是否相等。\n4.[ ]操作符**b[k]**表示b的第k位，既可以取值，也可以赋值。在10000位二进制数中，最低位为 b[0] ，最高位为 b[9999] 。\n5.method\n\n\n方法\n描述\n实例\n时间复杂度\n\n\n\nsize\nbitset 的长度\nint x &#x3D; b.size();\nO(1)\n\n\ncount\n返回有多少位为1\nint y &#x3D; b.count();\nO(n&#x2F;w)，w一般为64注\n\n\nany\n若所有位都为0，返回false；   若s至少一位为1，返回true\nbool a &#x3D; b.any();\nO(n&#x2F;w)，w一般为64\n\n\nnone\n若所有位都为0，返回true；   若s至少一位为1，返回falseb\nbool c &#x3D; b.none();\nO(n&#x2F;w)，w一般为64\n\n\nset\n把所有位变为1；                   把第k位改为v，即 b[k] &#x3D; v\nb.set();        b.set(k,v);\nO(1)\n\n\nreset\n把所有位变为0；                   把第k位改为0，即 b[k] &#x3D; 0\nb.reset();     b.reset(k);\nO(1)\n\n\nflip\n把所有位取反，即 s &#x3D; ~s；   把第k位取反，即 b[k]^&#x3D;1\nb.flip();         b.flip(k);\nO(1)\n\n\n注：bitset的count操作的复杂度未在C++ Reference 中标注。一般来说，其复杂度为关于bitset位数的线性复杂度，但实际效率可能稍快一些。\nmap1.aboutmap容器是一个键值对 key-value 的映射。其内部实现是一棵以 key 为关键码的红黑树。map的 key 和 value 可以是任意类型，其中 key 必须定义“小于号”运算符。在很多时候， map容器被当作Hash表使用，建立从复杂信息 key （如字符串）到简单信息 value （如一定范围内的整数）的映射。因为map基于平衡树实现，所以它的大部分操作的时间复杂度都在 O(logn) 级别，略慢于使用Hash函数实现的传统Hash表。从C++11开始，STL中新增了unordered_map等基于Hash函数实现的传统Hash表。\n2.声明和初始化#include &lt;map&gt;\t\t\t\t\t\t\t//头文件map&lt;key_type, value_type&gt; name;map&lt;long long, bool&gt; vis;map&lt;string, int&gt; hash;map&lt; pair&lt;int, int&gt;, vector&lt;int&gt; &gt; test;// 初始化构造map&lt;int, string&gt; map_test1;\t\t// 默认构造map&lt;int, string&gt; map_test2(map_test1.begin(), map_test1.end());\t// 范围构造map&lt;int, string&gt; map_test3 = map_test2;\t\t\t// 赋值构造 map&lt;int, string&gt; map_test4(map_test2);\t\t\t// 复制构造 // 内部是一个pair对象map&lt;int, string&gt; map_test5&#123; pair&lt;int, string&gt;(1, &quot;aaa&quot;),pair&lt;int, string&gt;(2, &quot;bbb&quot;) &#125;;// 使用make_pair 构造 pairmap&lt;int, string&gt; map_test6&#123; make_pair(1, &quot;abc&quot;), make_pair(2, &quot;xyz&quot;) &#125;;\n\n注：pair&lt;&gt;: C++内置的二元组，尖括号分别指定二元组的第一元、第二元的类型。可以用make_pair函数创建二元组，用成员变量first访问第一元、second访问第二元。在比较大小时，以第一元为第一关键字、第二元为第二关键字。\n3.迭代器map的迭代器与set一样，也是“双向访问迭代器”。对map的迭代器解除引用后，将得到一个二元组 pair&lt;key_type, value_type&gt;。\nmap&lt;key_type, value_type&gt;::iterator it;map&lt;string,int&gt;::iterator it;\n\n4.[ ]操作符**h[key]**返回key映射到的value的引用，时间复杂度为O(logn)。可以通过 h[key] 来得到 key 对应的 value，还可以对 h[key] 进行赋值操作，改变 key 对应的 value。若查找的 key 不存在，则执行 h[key] 后，h会自动新建一个二元组 (key, zero)，并返回 zero 的引用。这里 zero 表示一个广义“零值”，如整数 0、空字符串等。如果查找之后不对 h[key] 进行赋值，那么时间一长， h会包含很多无用的“零值二元值”，白白地占用了空间，降低了程序运行效率。强烈建议在用 [ ] 操作符查询之前，先用 find 方法检查 key 的存在性。\n5.method\n\n\n方法\n描述\n实例\n时间复杂度\n\n\n\nsize\n实际长度（包含的元素个数）\nint x &#x3D; m.size();\nO(1)\n\n\nempty\n是否为空\nbool y &#x3D; m.empty();\nO(1)\n\n\nclear\n清空\nm.clear();\nO(n)\n\n\nbegin\n首迭代器\nmap&lt;key_type, value_type&gt;::iterator it &#x3D; m.begin();\nO(1)\n\n\nend\n尾迭代器\nmap&lt;key_type, value_type&gt;::iterator it &#x3D; m.end();\nO(1)\n\n\ninsert\n插入，参数为pair&lt;key_type,value_type&gt;\nm.insert(make_pair(1,2));\nO(logn)\n\n\nerase\n删除，参数可以是key或者迭代器\nm.erase(2);            m.erase(it);\nO(logn)\n\n\nfind\n查找，查找key为x的二元组，返回指向该二元组的迭代器。若不存在，返回h.end()\nmap&lt;key_type, value_type&gt;::iterator it &#x3D;  m.find(x)\nO(logn)\n\n\nunordered_map1.aboutunordered_map 容器，直译过来就是”无序 map 容器”的意思。所谓“无序”，指的是 unordered_map 容器不会像 map 容器那样对存储的数据进行排序。换句话说，unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。具体来讲，unordered_map 容器和 map 容器一样，以键值对（pair类型）的形式存储数据，存储的各个键值对的键互不相同且不允许被修改。但由于 unordered_map 容器底层采用的是哈希表存储结构，该结构本身不具有对数据的排序功能，所以此容器内部不会自行对存储的键值对进行排序。\n2.定义和初始化#include &lt;unordered_map&gt;\t\t\t\t\t\t\t//头文件unordered_map&lt;key_type, value_type&gt; name;unordered_map&lt;long long, bool&gt; vis;unordered_map&lt;string, int&gt; hash;unordered_map&lt; pair&lt;int, int&gt;, vector&lt;int&gt; &gt; test;\n\n注：pair&lt;&gt;: C++内置的二元组，尖括号分别指定二元组的第一元、第二元的类型。可以用make_pair函数创建二元组，用成员变量first访问第一元、second访问第二元。在比较大小时，以第一元为第一关键字、第二元为第二关键字。\n3.迭代器对unordered_map的迭代器解除引用后，将得到一个二元组 pair&lt;key_type, value_type&gt;。\nunordered_map&lt;key_type, value_type&gt;::iterator it;unordered_map&lt;string,int&gt;::iterator it;\n\n遍历unordered_map：\nfor(unordered_map&lt;string,int&gt;::iterator it = hash.begin(); it != hash.end(); it++)&#123;    cout&lt;&lt;(*it).first&lt;&lt;&#x27; &#x27;&lt;&lt;(*it).second&lt;&lt;endl;&#125;\n\n4.[ ]操作符**h[key]**返回key映射到的value的引用，时间复杂度为O(logn)。可以通过 h[key] 来得到 key 对应的 value，还可以对 h[key] 进行赋值操作，改变 key 对应的 value。若查找的 key 不存在，则执行 h[key] 后，h会自动新建一个二元组 (key, zero)，并返回 zero 的引用。这里 zero 表示一个广义“零值”，如整数 0、空字符串等。如果查找之后不对 h[key] 进行赋值，那么时间一长， h会包含很多无用的“零值二元值”，白白地占用了空间，降低了程序运行效率。强烈建议在用 [ ] 操作符查询之前，先用 find 方法检查 key 的存在性。\n5.method\n\n\n方法\n描述\n实例\n时间复杂度\n\n\n\nsize\n实际长度（包含的元素个数）\nint x &#x3D; m.size();\nO(1)\n\n\nempty\n是否为空\nbool y &#x3D; m.empty();\nO(1)\n\n\nclear\n清空\nm.clear();\nO(n)\n\n\nbegin\n首迭代器\nmap&lt;key_type, value_type&gt;::iterator it &#x3D; m.begin();\nO(1)\n\n\nend\n尾迭代器\nmap&lt;key_type, value_type&gt;::iterator it &#x3D; m.end();\nO(1)\n\n\ninsert\n插入，参数为pair&lt;key_type,value_type&gt;\nm.insert(make_pair(1,2));\nO(logn)\n\n\nerase\n删除，参数可以是key或者迭代器\nm.erase(2);            m.erase(it);\nO(logn)\n\n\nfind\n查找，查找key为x的二元组，返回指向该二元组的迭代器。若不存在，返回h.end()\nmap&lt;key_type, value_type&gt;::iterator it &#x3D;  m.find(x)\nO(logn)\n\n\n","categories":["Algorithm"],"tags":["algorithm"]},{"title":"八字","url":"/2025/08/01/Metaphysics/%E5%85%AB%E5%AD%97/","content":"学点玄学😝\n\n\n批八字流程1.排盘后过三关排盘网站：灵机周易大学堂 八字排盘过三关——断三件非常准的事\n2.分清日元强弱3.取喜用与忌凶之神4.断格局，分析性格和一生的追求八正格：正印格、正官格、食神格、伤官格、七杀格、枭印格、正财格、偏财格，劫财和比肩不入格\n5.分层次，断命格高低，一生的成就阴阳平衡，五行平衡，强弱平衡，燥湿平衡，运程占好运比例，十神吉凶比例\n6.看日柱空亡是什么十神7.看墓库属性8.看六亲关系9.看各个年龄段的运程10.看八字风水，家中摆放的物品11.看病症12.看财富13.看官运14.看夫妻关系15.看大运流年灾祸16.看十神的缺失看出生地周围建筑物1.八字中方向的问题​\t\t\t上南左东\t\t\t\t右西​\t\t\t下北\n2.出生地和现住房的问题现住房必须住3年以上，个人能量才会影响到周围物品\n3.天干地支代表的意像甲：树林\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t乙：花园，草原，庄稼地，矮树木\t\t\t\t\t\t\t\t\t\t\t\t丙：太阳光，燃烧炉，高大亮灯光丁：微弱的亮光戊：山，广阔的空地，高大的建筑物己：凹陷，小的空地庚：高大的金属物，电线杆，发射塔，路辛：低小的金属物壬：河，湖，海癸：小溪，沟，下水道子：小溪，井丑：坟地，池塘寅：树林卯：库房，花园，小树林辰：水库，小溪，井巳：阳光普照午：小火堆，田园，道观未：田园，草地，庄稼地申：路，机器厂房酉：珠宝，工具仓库戌：庙，马路，空旷的空地亥：河，湖，海，水库，稻田\n看一个人何时发财","categories":["Metaphysics"]}]